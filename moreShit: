#!/usr/bin/env python3
import os, time, json, shutil, hashlib
from pathlib import Path
from http.server import BaseHTTPRequestHandler, HTTPServer
from threading import Thread, Event
import yaml, redis

CONFIG_PATH = os.getenv("COLD_CONFIG", "/app/cold_policy.yaml")
COLD_PATH = Path(os.getenv("COLD_PATH", "/mnt/cold_storage"))
ARCHIVE_PATH = Path(os.getenv("ARCHIVE_PATH", "/mnt/external_archive"))
REDIS_URL = os.getenv("REDIS_URL", "redis://redis:6379/0")
DRAIN_KEY = os.getenv("DRAIN_KEY", "filer:drain_mode")
METRICS_PORT = int(os.getenv("METRICS_PORT", "9100"))
POLL_SEC = int(os.getenv("POLL_SEC", "15"))

METRICS = {"cold_bytes":0,"archive_bytes":0,"files_pruned":0,"files_offloaded":0,"drain_active":0}

def load_cfg():
    with open(CONFIG_PATH, "r") as f:
        return yaml.safe_load(f) or {}

def dir_bytes(p: Path):
    total = 0
    for q in p.rglob("*"):
        try:
            if q.is_file():
                total += q.stat().st_size
        except Exception:
            pass
    return total

def sha256_file(p: Path, buf=65536):
    h = hashlib.sha256()
    with p.open("rb") as f:
        while True:
            b = f.read(buf)
            if not b:
                break
            h.update(b)
    return h.hexdigest()

class MetricsHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        if self.path != "/metrics":
            self.send_response(404); self.end_headers(); return
        out = []
        for k,v in METRICS.items():
            out.append(f"# HELP {k} {k}")
            out.append(f"# TYPE {k} gauge")
            out.append(f"{k} {int(v)}")
        data = "\n".join(out).encode()
        self.send_response(200)
        self.send_header("Content-Type","text/plain; version=0.0.4")
        self.send_header("Content-Length", str(len(data)))
        self.end_headers()
        self.wfile.write(data)

def serve_metrics(stop_evt: Event):
    srv = HTTPServer(("0.0.0.0", METRICS_PORT), MetricsHandler)
    srv.timeout = 1.0
    while not stop_evt.is_set():
        srv.handle_request()

def run_manager():
    r = redis.from_url(REDIS_URL)
    stop_evt = Event()
    t = Thread(target=serve_metrics, args=(stop_evt,), daemon=True)
    t.start()
    try:
        while True:
            cfg = load_cfg()
            policy = cfg.get("cold_storage_policy", {})
            mode = policy.get("mode", "rolling")
            retention_days = int(policy.get("retention_days", 60))
            threshold_pct = float(policy.get("threshold_pct", 0.95))
            verify_checksum = bool(policy.get("verify_checksum", True))
            cap_gb = float(policy.get("assumed_capacity_gb", 250))

            cold_bytes = dir_bytes(COLD_PATH)
            METRICS["cold_bytes"] = cold_bytes
            archive_bytes = dir_bytes(ARCHIVE_PATH) if ARCHIVE_PATH.exists() else 0
            METRICS["archive_bytes"] = archive_bytes

            drain = (cold_bytes / (cap_gb * (1024**3))) >= threshold_pct
            METRICS["drain_active"] = 1 if drain else 0
            r.set(DRAIN_KEY, "true" if drain else "false", ex=60)

            if mode in ("rolling","dual"):
                files = []
                now = time.time()
                for q in COLD_PATH.rglob("*"):
                    if q.is_file():
                        try:
                            st = q.stat()
                            files.append((q, st.st_mtime))
                        except Exception:
                            pass
                files.sort(key=lambda x: x[1])
                for q, mtime in files:
                    age_days = (now - mtime) / 86400
                    if age_days > retention_days or drain:
                        if mode == "dual" or verify_checksum:
                            ARCHIVE_PATH.mkdir(parents=True, exist_ok=True)
                            dst = ARCHIVE_PATH / q.name
                            if not dst.exists():
                                shutil.copy2(q, dst)
                                METRICS["files_offloaded"] += 1
                                if verify_checksum:
                                    try:
                                        if sha256_file(q) != sha256_file(dst):
                                            continue
                                    except Exception:
                                        continue
                            try:
                                q.unlink()
                                METRICS["files_pruned"] += 1
                            except Exception:
                                pass
                        else:
                            try:
                                q.unlink()
                                METRICS["files_pruned"] += 1
                            except Exception:
                                pass

            time.sleep(POLL_SEC)
    finally:
        stop_evt.set()

if __name__ == "__main__":
    run_manager()
